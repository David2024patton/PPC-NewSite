"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverEntryVirtualId = void 0;
exports.serverProductionEntryPlugin = serverProductionEntryPlugin;
const utils_js_1 = require("./utils.js");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const serverEntryFileNameBase_js_1 = require("../shared/serverEntryFileNameBase.js");
const debugLogsBuildTime_js_1 = require("./debugLogsBuildTime.js");
const url_1 = require("url");
const module_1 = require("module");
const importMetaUrl = 
// @ts-ignore import.meta is shimmed at dist/cjs by dist-cjs-fixup.js
`file://${__filename}` +
    // trick to avoid `@vercel/ncc` to glob import
    (() => '')();
const __dirname_ = (0, utils_js_1.toPosixPath)(path_1.default.dirname((0, url_1.fileURLToPath)(importMetaUrl)));
const isCJSEnv = 'require.resolve' === 'require.resolve'; // see dist-cjs-fixup.js
const require_ = (0, module_1.createRequire)(importMetaUrl);
const autoImporterFilePath = (0, utils_js_1.toPosixPath)(require_.resolve('../runtime/autoImporter.js'));
const serverEntryVirtualId = 'virtual:@brillout/vite-plugin-server-entry:serverEntry';
exports.serverEntryVirtualId = serverEntryVirtualId;
// https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
const virtualIdPrefix = '\0';
// Using the semver major to determine compatible versions is a much inferior solution. Because, for example, when the user updates Vike > @brillout/vite-plugin-server-entry from version 0.4.8 (`apiVersion===4`) to 0.4.10 (`apiVersion===5`) then things just works because Telefunc > @brillout/vite-plugin-server-entry also updates to `0.4.10`. On the other hand, when the user updates Vike > @brillout/vite-plugin-server-entry to 0.5.0 then this won't update Telefunc > @brillout/vite-plugin-server-entry which is stuck to 0.4.x and the user is forced to update Telefunc.
const apiVersion = 5;
/**
 * This plugin does two things:
 *  - Generates a "server entry" file at `dist/server/entry.js`.
 *  - Generates a "auto importer" file at `node_modules/@brillout/vite-plugin-server-entry/dist/runtime/autoImporter.js`.
 *
 * See https://github.com/brillout/vite-plugin-server-entry#what-it-does for more information.
 */
function serverProductionEntryPlugin(pluginConfigProvidedByLibrary) {
    const pluginName = `@brillout/vite-plugin-server-entry:${pluginConfigProvidedByLibrary.libraryName.toLowerCase()}`;
    let config;
    const { libraryName } = pluginConfigProvidedByLibrary;
    (0, utils_js_1.assert)(libraryName);
    let isNotLeaderInstance;
    let librariesLength;
    const skip = (viteEnv) => {
        (0, utils_js_1.assert)('boolean' === typeof isNotLeaderInstance);
        return isNotLeaderInstance || !(0, utils_js_1.isViteServerSide)(config, viteEnv);
    };
    return [
        {
            name: `${pluginName}:config:pre`,
            apply: 'build',
            // We must run the pre-hook configResolved() of *all* libraries before any post-hook configResolved() hook is called (otherwise isLeaderPluginInstance() will miss libraries and won't work)
            enforce: 'pre',
            configResolved: {
                order: 'pre',
                handler(configUnresolved) {
                    config = resolveConfig(configUnresolved, libraryName, pluginConfigProvidedByLibrary);
                    (0, utils_js_1.assert)(config._vitePluginServerEntry.libraries.find((l) => l.libraryName === libraryName));
                },
            },
        },
        {
            name: `${pluginName}:config:post`,
            apply: 'build',
            // We need to run this plugin after other plugin instances, so that assertApiVersions() works also for libraries using older plugin versions
            enforce: 'post',
            configResolved: {
                order: 'post',
                handler() {
                    (0, utils_js_1.assertUsage)(typeof config.build.ssr !== 'string', "Setting the server build entry over the Vite configuration `build.ssr` (i.e. `--ssr path/to/entry.js`) isn't supported (because of a Vite bug), see workaround at https://github.com/brillout/vite-plugin-server-entry/issues/9#issuecomment-2027641624");
                    {
                        const prev = librariesLength;
                        librariesLength = config._vitePluginServerEntry.libraries.length;
                        (0, utils_js_1.assert)([undefined, librariesLength].includes(prev));
                    }
                    {
                        const prev = isNotLeaderInstance;
                        isNotLeaderInstance = !isLeaderPluginInstance(config, libraryName);
                        (0, utils_js_1.assert)([undefined, isNotLeaderInstance].includes(prev));
                    }
                    if (skip(undefined))
                        return;
                    assertApiVersions(config, pluginConfigProvidedByLibrary.libraryName);
                    applyPluginConfigProvidedByUser(config);
                    if (!config._vitePluginServerEntry.disableServerEntryEmit) {
                        const serverEntryName = getServerEntryName(config);
                        config.build.rollupOptions.input = (0, utils_js_1.injectRollupInputs)({ [serverEntryName]: serverEntryVirtualId }, config);
                    }
                },
            },
        },
        {
            name: `${pluginName}:hooks`,
            apply: 'build',
            buildStart: {
                handler() {
                    if (skip(this.environment))
                        return;
                    clearAutoImporter(config);
                },
            },
            resolveId: {
                filter: {
                    id: new RegExp(`^${(0, utils_js_1.escapeRegex)(serverEntryVirtualId)}$`),
                },
                handler(id) {
                    if (skip(this.environment))
                        return;
                    if (id === serverEntryVirtualId) {
                        return virtualIdPrefix + serverEntryVirtualId;
                    }
                },
            },
            load: {
                filter: {
                    id: new RegExp(`^${(0, utils_js_1.escapeRegex)(virtualIdPrefix + serverEntryVirtualId)}$`),
                },
                handler(id) {
                    if (skip(this.environment))
                        return;
                    (0, utils_js_1.assert)(id !== serverEntryVirtualId);
                    if (id === virtualIdPrefix + serverEntryVirtualId) {
                        const serverProductionEntry = getServerProductionEntryAll(config, this.environment);
                        return serverProductionEntry;
                    }
                },
            },
            generateBundle: {
                handler(_rollupOptions, bundle) {
                    if (skip(this.environment))
                        return;
                    if (this.environment && this.environment.name !== 'ssr')
                        return;
                    // Write node_modules/@brillout/vite-plugin-server-entry/dist/autoImporter.js
                    if (!isAutoImportDisabled(config)) {
                        const entry = findServerEntry(bundle, getOutDir(config, this.environment));
                        (0, utils_js_1.assert)(entry);
                        const entryFileName = entry.fileName;
                        if (!entryFileName)
                            (0, utils_js_1.assert)(false, { entry });
                        setAutoImporter(config, this.environment, entryFileName);
                    }
                    else {
                        (0, debugLogsBuildTime_js_1.debugLogsBuildtime)({ disabled: true, paths: null });
                    }
                },
            },
        },
    ];
}
function resolveConfig(configUnresolved, libraryName, pluginConfigProvidedByLibrary) {
    (0, utils_js_1.assert)(pluginConfigProvidedByLibrary.libraryName === libraryName);
    const pluginConfigResolved = configUnresolved._vitePluginServerEntry ?? {
        libraries: [],
        apiVersion,
        inject: false,
        disableAutoImport: false,
        disableServerEntryEmit: false,
    };
    (0, utils_js_1.objectAssign)(configUnresolved, {
        _vitePluginServerEntry: pluginConfigResolved,
    });
    const libraryNew = {
        getServerProductionEntry: pluginConfigProvidedByLibrary.getServerProductionEntry,
        libraryName,
        pluginVersion: utils_js_1.projectInfo.projectVersion,
        apiVersion,
    };
    const libraryFound = pluginConfigResolved.libraries.find((l) => l.libraryName === libraryName);
    if (!libraryFound) {
        pluginConfigResolved.libraries.push(libraryNew);
    }
    else {
        (0, utils_js_1.assert)((0, utils_js_1.deepEqual)(libraryNew, libraryFound));
    }
    const config = configUnresolved;
    return config;
}
function applyPluginConfigProvidedByUser(config) {
    const pluginConfigResolved = config._vitePluginServerEntry;
    const pluginConfigProvidedByUser = config.vitePluginServerEntry ?? {};
    if (pluginConfigProvidedByUser.inject !== undefined) {
        pluginConfigResolved.inject = pluginConfigProvidedByUser.inject;
    }
    if (pluginConfigProvidedByUser.disableAutoImport !== undefined) {
        pluginConfigResolved.disableAutoImport = pluginConfigProvidedByUser.disableAutoImport;
    }
    if (pluginConfigProvidedByUser.disableServerEntryEmit !== undefined) {
        pluginConfigResolved.disableServerEntryEmit = pluginConfigProvidedByUser.disableServerEntryEmit;
    }
}
function isLeaderPluginInstance(config, libraryName) {
    const { libraries } = config._vitePluginServerEntry;
    const pluginVersionCurrent = utils_js_1.projectInfo.projectVersion;
    const library = libraries.find((l) => l.libraryName === libraryName);
    (0, utils_js_1.assert)(library);
    const isNotUsingNewestPluginVersion = libraries.some((lib) => {
        // Can be undefined when set by an older @brillout/vite-plugin-dist-importer version
        if (!lib.pluginVersion)
            return false;
        return isHigherVersion(lib.pluginVersion, pluginVersionCurrent);
    });
    if (isNotUsingNewestPluginVersion)
        return false;
    const librariesUsingNewestPluginVersion = libraries.filter((lib) => lib.pluginVersion === pluginVersionCurrent);
    return librariesUsingNewestPluginVersion[0] === library;
}
function getServerProductionEntryAll(config, viteEnv) {
    (0, utils_js_1.assert)((0, utils_js_1.isViteServerSide)(config, viteEnv));
    const serverProductionEntry = [
        '// Generated by https://github.com/brillout/vite-plugin-server-entry',
        ...config._vitePluginServerEntry.libraries.map((library) => {
            // Should be true because of assertApiVersions()
            (0, utils_js_1.assert)(getLibraryApiVersion(library) === apiVersion);
            const entryCode = (library.getServerProductionEntry ??
                // Support old `getServerProductionEntry()` name: it was previously called `getImporterCode()`.
                // TODO/api-version-bump: We'll be able to remove this next time we bump `apiVersion`.
                // @ts-expect-error
                library.getImporterCode)();
            return entryCode;
        }),
    ].join('\n');
    return serverProductionEntry;
}
function setAutoImporter(config, viteEnv, entryFileName) {
    const { distServerPathRelative, distServerPathAbsolute } = getDistServerPathRelative(config, viteEnv);
    const serverEntryFilePathRelative = path_1.default.posix.join(distServerPathRelative, entryFileName);
    const serverEntryFilePathAbsolute = path_1.default.posix.join(distServerPathAbsolute, entryFileName);
    const { root } = config;
    (0, utils_js_1.assertPosixPath)(root);
    (0, utils_js_1.assert)(!isAutoImportDisabled(config));
    (0, utils_js_1.assert)(!(0, utils_js_1.isYarnPnP)());
    writeAutoImporterFile(({ autoImporterFilePathResolved, exportStatement, isCJS }) => [
        `${exportStatement}status = 'SET';`,
        `${exportStatement}pluginVersion = ${JSON.stringify(utils_js_1.projectInfo.projectVersion)};`,
        `${exportStatement}loadServerEntry = async () => { await import(${JSON.stringify(serverEntryFilePathRelative)}); };`,
        `${exportStatement}paths = {`,
        `  autoImporterFilePathOriginal: ${JSON.stringify(autoImporterFilePathResolved)},`,
        `  autoImporterFilePathActual: (() => { try { return ${isCJS ? '__filename' : '`file://${__filename}`'} } catch { return null } })(),`,
        `  serverEntryFilePathRelative: ${JSON.stringify(serverEntryFilePathRelative)},`,
        `  serverEntryFilePathOriginal: ${JSON.stringify(serverEntryFilePathAbsolute)},`,
        `  serverEntryFilePathResolved: () => ${isCJS ? 'require' : 'import.meta'}.resolve(${JSON.stringify(serverEntryFilePathRelative)}),`,
        '};',
        '',
    ].join('\n'));
}
function clearAutoImporter(config) {
    if ((0, utils_js_1.isYarnPnP)())
        return;
    const status = isAutoImportDisabled(config) ? 'DISABLED' : 'BUILDING';
    writeAutoImporterFile(({ exportStatement }) => [`${exportStatement}status = '${status}';`, ''].join('\n'));
}
/** Is `semver1` higher than `semver2`?*/
function isHigherVersion(semver1, semver2) {
    const parsed1 = parseSemver(semver1);
    const parsed2 = parseSemver(semver2);
    for (let i = 0; i <= parsed1.parts.length - 1; i++) {
        if (parsed1.parts[i] !== parsed2.parts[i]) {
            return parsed1.parts[i] > parsed2.parts[i];
        }
    }
    if (parsed1.isPreRelease !== parsed2.isPreRelease) {
        return parsed1.isPreRelease;
    }
    return false;
}
function parseSemver(semver) {
    let isPreRelease = false;
    if (semver.includes('-')) {
        isPreRelease = true;
        semver = semver.split('-')[0]; // '0.2.16-commit-89bbe89' => '0.2.16'
    }
    (0, utils_js_1.assert)(/^[0-9\.]+$/.test(semver));
    const partsStr = semver.split('.');
    (0, utils_js_1.assert)(partsStr.length === 3);
    const parts = partsStr.map((n) => parseInt(n, 10));
    return { parts, isPreRelease };
}
function getOutDir(config, viteEnv) {
    const outDir = !viteEnv
        ? // Vite 5
            config.build.outDir
        : // Vite 6 or above
            viteEnv.config.build.outDir;
    (0, utils_js_1.assert)(outDir);
    return outDir;
}
function getDistServerPathRelative(config, viteEnv) {
    (0, utils_js_1.assert)((0, utils_js_1.isViteServerSide)(config, viteEnv));
    const { root } = config;
    const importerDir = __dirname_;
    (0, utils_js_1.assertPosixPath)(importerDir);
    (0, utils_js_1.assert)((0, utils_js_1.isAbsolutePath)(importerDir));
    (0, utils_js_1.assertPosixPath)(root);
    (0, utils_js_1.assert)((0, utils_js_1.isAbsolutePath)(root));
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let outDir = getOutDir(config, viteEnv);
    // SvelteKit doesn't set config.build.outDir to a posix path
    outDir = (0, utils_js_1.toPosixPath)(outDir);
    if ((0, utils_js_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_js_1.assert)(!(0, utils_js_1.isAbsolutePath)(outDir));
    }
    const distServerPathRelative = path_1.default.posix.join(rootRelative, outDir);
    const distServerPathAbsolute = path_1.default.posix.join(root, outDir);
    (0, debugLogsBuildTime_js_1.debugLogsBuildtime)({
        disabled: false,
        paths: { importerDir, root, rootRelative, outDir, distServerPathRelative, distServerPathAbsolute },
    });
    return { distServerPathRelative, distServerPathAbsolute };
}
function assertApiVersions(config, currentLibraryName) {
    const librariesNeedingUpdate = [];
    ['vitePluginDistImporter', '_vitePluginImportBuild'].forEach((key) => {
        if (key in config) {
            const dataOld = config[key];
            dataOld.libraries.forEach((lib) => {
                (0, utils_js_1.assert)(lib.libraryName);
                librariesNeedingUpdate.push(lib.libraryName);
            });
        }
    });
    const pluginConfigResolved = config._vitePluginServerEntry;
    pluginConfigResolved.libraries.forEach((library) => {
        const apiVersionLib = getLibraryApiVersion(library);
        if (apiVersionLib < apiVersion) {
            librariesNeedingUpdate.push(library.libraryName);
        }
        else {
            // Should be true thanks to isLeaderPluginInstance()
            (0, utils_js_1.assert)(apiVersionLib === apiVersion);
        }
    });
    if (librariesNeedingUpdate.length > 0) {
        const libs = (0, utils_js_1.joinEnglish)(librariesNeedingUpdate, 'and');
        // We purposely use `throw new Error()` instead of `assertUsage()`, in order to not confuse the user with superfluous information
        throw new Error(`Update ${libs} to its latest version and try again: ${currentLibraryName} requires a newer version of ${libs}.`);
    }
}
function getLibraryApiVersion(library) {
    // library.apiVersion can be undefined when set by an older @brillout/vite-plugin-server-entry version
    const apiVersionLib = library.apiVersion ?? 1;
    return apiVersionLib;
}
function findServerEntry(bundle, outDir) {
    const entry = (0, utils_js_1.findRollupBundleEntry)(serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative, bundle, outDir) ||
        (0, utils_js_1.findRollupBundleEntry)(serverEntryFileNameBase_js_1.serverEntryFileNameBase, bundle, outDir);
    (0, utils_js_1.assertUsage)(entry, errMsgEntryRemoved([
        //
        serverEntryFileNameBase_js_1.serverEntryFileNameBase,
        serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative,
    ], Object.keys(bundle), Object.values(bundle)
        .map((entry) => entry.name)
        .filter(utils_js_1.isNotNullish)));
    return entry;
}
function errMsgEntryRemoved(entriesMissing, entryKeys, entryNames) {
    const list = (items) => '[' + items.map((e) => `'${e}'`).join(', ') + ']';
    return [
        entriesMissing.length === 1
            ? `Cannot find build server entry '${entriesMissing[0]}'.`
            : `Cannot find build server entry, searching for:  ${list(entriesMissing)} (none of them exist, but one of these should exist).`,
        `Make sure your Vite config (or that of a Vite plugin) doesn't remove/overwrite server build entries.`,
        `(Found entry names: ${list(entryNames)}, found entry keys: ${list(entryKeys)}.)`,
    ].join(' ');
}
function isAutoImportDisabled(config) {
    const { disableAutoImport } = config._vitePluginServerEntry;
    return (0, utils_js_1.isYarnPnP)() || disableAutoImport;
}
function getServerEntryName(config) {
    const entries = (0, utils_js_1.normalizeRollupInput)(config.build.rollupOptions.input);
    (0, utils_js_1.assert)(entries[serverEntryFileNameBase_js_1.serverEntryFileNameBase] !== serverEntryVirtualId &&
        entries[serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative] !== serverEntryVirtualId);
    const serverEntryName = !entries[serverEntryFileNameBase_js_1.serverEntryFileNameBase]
        ? serverEntryFileNameBase_js_1.serverEntryFileNameBase
        : serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative;
    (0, utils_js_1.assert)(!entries[serverEntryName]);
    return serverEntryName;
}
function writeAutoImporterFile(getFileContent) {
    {
        const { isCJS } = analyzeDistPath(autoImporterFilePath);
        (0, utils_js_1.assert)(isCJS === isCJSEnv);
    }
    const autoImporterFilePathEsm = autoImporterFilePath.replace('/dist/cjs/', '/dist/esm/');
    const autoImporterFilePathCjs = autoImporterFilePath.replace('/dist/esm/', '/dist/cjs/');
    [autoImporterFilePathEsm, autoImporterFilePathCjs].forEach((autoImporterFilePathResolved) => {
        const { exportStatement, isCJS } = analyzeDistPath(autoImporterFilePathResolved);
        const fileContent = getFileContent({ autoImporterFilePathResolved, exportStatement, isCJS });
        (0, fs_1.writeFileSync)(autoImporterFilePathResolved, fileContent);
    });
}
function analyzeDistPath(autoImporterFilePath) {
    (0, utils_js_1.assertPosixPath)(autoImporterFilePath);
    const isCJS = autoImporterFilePath.includes('/dist/cjs/');
    const isESM = autoImporterFilePath.includes('/dist/esm/');
    if (isCJS)
        (0, utils_js_1.assert)(autoImporterFilePath.split('/dist/cjs/').length === 2);
    if (isESM)
        (0, utils_js_1.assert)(autoImporterFilePath.split('/dist/esm/').length === 2);
    (0, utils_js_1.assert)(isCJS || isESM);
    (0, utils_js_1.assert)(!(isCJS && isESM));
    const exportStatement = isCJS ? 'exports.' : 'export const ';
    return { isCJS, exportStatement };
}
